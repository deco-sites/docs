# ðŸ“˜ Mini Guide â€“ Useful Tips for Working with Deco CMS

---
## Technologies Used by Deco Sites

1. Preact
2. HTMX
3. Deco Framework
4. Tailwind CSS
5. Deno
6. All Deco pages are rendered on the server using Server Side Rendering (SSR) technique.

## About Deco Framework and CMS

- The Deco framework is based on the concept of blocks. Blocks are TypeScript functions that have common behavior and particular semantics. Blocks are written in folders with their name.
- There are several types of blocks like:
    - sections: which render HTML with Preact and can have inline loaders/actions;
    - loaders: which are data loaders and can connect to outside APIs;
    - actions: are like loaders but accessed via POST
    - pages: are like sections but have path and sections[] props
- For example, a "sections" type block is located inside the `/sections` folder of the project.
- A block is a TypeScript file that has a default export of a function and interfaces for its input and output types.

### How to Write a Block

Writing a section type block:

```tsx
// file /sections/HelloWorld.tsx
interface HelloWorldProps {
    name: string; // Allows the name property to be configured in the Deco CMS
}

export default function HelloWorld(props: Props) {
    return <div>Hello, world! My name is {props.name}</div>
}
```

### How to Use the Block

To use the block, simply write a JSON file with a unique identifier in the folder /.deco/blocks/<block-id>.json.
The JSON content must contain the `__resolveType` property that uniquely identifies the file.

```json
// /.deco/blocks/hello.json
{
  "__resolveType": "site/sections/HelloWorld.tsx",
  "name": "My Example Name"
}
```

### How to Compose Blocks

- Blocks can be composed of other blocks. What allows one block to be composed of another are the TypeScript input and output types. Example:

```tsx
// /loaders/GetAnySection.ts
import type {Section} from "@deco/deco"
interface Props {
  loadingSection: Section
}

export function GetAnySection({ loadingSection }: Props): Promise<string> {
    const section = <loadingSection.Section {...loadingSection.Props} />
    return renderToHTML(section);
}
```

To reference this saved hello block, it can be done through the <block-id>. Example:
```json
{ // any other block that accepts a Section.
  "loadingSection": { "__resolveType": "hello" } // hello, the file name, is the block ID.
}
```


- The interface of each block is compiled and converted into a form in the Deco CMS to be edited by the business user who changes the content of the site.


## The Page Block

The page block contains a list of Sections, which are Preact components.

```tsx
import type {Section} from "@deco/deco";
interface Props {
    path: string; // Page path
    sections: Section[]
}

export default function Page() {/* ..Page code here */}
```

## What is the HTML Structure of a Deco Page?

```html
<html>
 <head>
  <!-- scripts and links necessary for the page to work -->
 </head>
 <body>
   <section data-manifest-key="/path/to/component.tsx">{Result of Preact component rendering}</section>
   <section data-manifest-key="/path/to/component.tsx">{Result of Preact component rendering}</section>
   ... multiple sections
   <section data-manifest-key="/path/to/component.tsx">{Result of Preact component rendering}</section>
 </body>
</html>
```

## ðŸ§  Identifying Which Component Rendered Each Section

Each `<section>` tag in the HTML generated by Deco includes a `data-manifest-key` attribute:

```html
<section data-manifest-key="path/to/component.tsx">
```

This value indicates the **path of the file in the file system** that originated that section.
